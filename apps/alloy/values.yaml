# Alloy values for homelab log collection
# Deployed as DaemonSet to collect logs from all nodes

# Run as DaemonSet - one pod per node
alloy:
  # Configure the Alloy pipeline
  # This uses River configuration language
  configMap:
    content: |
      //
      // ALLOY LOG COLLECTION PIPELINE
      //
      // Flow: discovery.kubernetes -> discovery.relabel -> loki.source.kubernetes -> loki.write
      //
      // This pipeline:
      // 1. Discovers all pods in the cluster
      // 2. Extracts useful metadata (namespace, pod name, container, app labels)
      // 3. Collects logs via Kubernetes API (no host filesystem access needed)
      // 4. Ships logs to Loki
      //

      // ============================================================================
      // STEP 1: Pod Discovery
      // ============================================================================
      // Discovers all pods across all namespaces in the cluster.
      // The Kubernetes API is queried to find pod endpoints.
      discovery.kubernetes "pods" {
        role = "pod"
      }

      // ============================================================================
      // STEP 2: Relabeling (Metadata Extraction)
      // ============================================================================
      // Transforms Kubernetes metadata into Loki labels.
      // These labels let you query logs like: {namespace="argocd", app="argocd-server"}
      discovery.relabel "pods" {
        targets = discovery.kubernetes.pods.targets

        // Extract namespace from pod metadata
        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          target_label  = "namespace"
        }

        // Extract pod name
        rule {
          source_labels = ["__meta_kubernetes_pod_name"]
          target_label  = "pod"
        }

        // Extract container name (pods can have multiple containers)
        rule {
          source_labels = ["__meta_kubernetes_pod_container_name"]
          target_label  = "container"
        }

        // Extract node name (useful for debugging node-specific issues)
        rule {
          source_labels = ["__meta_kubernetes_pod_node_name"]
          target_label  = "node"
        }

        // Extract common app label (app=xxx)
        rule {
          source_labels = ["__meta_kubernetes_pod_label_app"]
          target_label  = "app"
        }

        // Extract app.kubernetes.io/name label (standard k8s label)
        rule {
          source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
          target_label  = "app_name"
        }

        // Extract app.kubernetes.io/component label
        rule {
          source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_component"]
          target_label  = "component"
        }
      }

      // ============================================================================
      // STEP 3: Log Collection
      // ============================================================================
      // Collects logs from pods using the Kubernetes API.
      //
      // Why Kubernetes API instead of host filesystem?
      // - No need to mount /var/log/pods from the host
      // - No privileged security context required
      // - Works with any Kubernetes distribution
      // - Cleaner and more secure
      loki.source.kubernetes "pods" {
        targets    = discovery.relabel.pods.output
        forward_to = [loki.write.default.receiver]
      }

      // ============================================================================
      // STEP 4: Ship to Loki
      // ============================================================================
      // Sends collected logs to Loki's push API.
      // The URL uses Kubernetes DNS: <service>.<namespace>:<port>
      loki.write "default" {
        endpoint {
          url = "http://loki.loki:3100/loki/api/v1/push"
        }
      }

  # Resource limits for homelab
  resources:
    requests:
      cpu: 50m
      memory: 64Mi
    limits:
      cpu: 200m
      memory: 256Mi

# Controller type - DaemonSet ensures one Alloy pod per node
controller:
  type: daemonset

# Create RBAC resources for Kubernetes API access
rbac:
  create: true

# Service account for RBAC
serviceAccount:
  create: true
